<?xml version='1.0' encoding='utf-8'?>

<!--****************************************************************************
* \file memory-2.0.cypersonality
* \version 2.0
*
* \brief
* Memory personality description file.
*
********************************************************************************
* \copyright
* Copyright (c) (2025), Cypress Semiconductor Corporation (an Infineon company) or
* an affiliate of Cypress Semiconductor Corporation.
* SPDX-License-Identifier: Apache-2.0
*
* Licensed under the Apache License, Version 2.0 (the 'License');
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an 'AS IS' BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*****************************************************************************-->

<PersonalityTemplate id='memory' name='Memory Regions' version='2.0' xmlns='http://cypress.com/xsd/cyhwpersonality_v14'>
  <Constants>
    <Const id='MAX_REGIONS' value='64' />
    <Const id='MAX_CORES' value='4' />
    <Const id='MAX_VIEW_MAPS' value='4' />
    <Const id='MAX_MEMORIES' value='16' />
    <Const id='MEMORY_LOCATION_PREFIX' value='IFX_MEMORY_TYPE_' />
  </Constants>

  <VirtualResourceDefinition ipblock='VirtualResource' type='vres' count='1'>
    <VirtualResourceDefinition type='reserved_memory_region' display_name='Reserved Region $idx' display_path='Memory' display_mode='DYNAMIC' count='25' />
    <VirtualResourceDefinition type='memory_region_data' display_name='Memory Region $idx' display_path='Memory' display_mode='DYNAMIC' count='$MAX_REGIONS' />
    <VirtualResourceDefinition type='memory' display_name='Memory' display_path='' count='1'>
      <DependentBlock type='vres.reserved_memory_region'/>
      <DependentBlock type='vres.memory_region_data'/>
    </VirtualResourceDefinition>
  </VirtualResourceDefinition>

  <FittingRules>
    <MappingRules>
      <IpBlock name='VirtualResource'>
        <Param name='HAS_MEMORY_DATA' value='1' />
      </IpBlock>
      <Resource name='vres\.memory' />
      <OperatingMode value='MCU' />
    </MappingRules>
  </FittingRules>

  <BehaviorImplementation>
    <Implements type='memory_regions_v2'>
      <ExposedMember key='maxSupportedRegions' paramId='maxSupportedRegions'/>
      <ExposedMember key='maxSupportedCores' paramId='maxSupportedCores'/>
      <ExposedMember key='maxSupportedViewMaps' paramId='maxSupportedViewMaps'/>
    </Implements>
  </BehaviorImplementation>

  <Parameters>
    <ParamDoc id='pdlDocMemoryRegions' name='Memory Regions Help' group='Overview' linkText='Defines memory regions to generate partial linker scripts for in GeneratedSource.' visible='true' default='' desc='' />
    <ParamDoc id='pdlDocSummary' name='Summary Help' group='Overview' linkText='Displays a live image of how memory has been configured.' visible='true' default='' desc='' />
    <ParamDoc id='pdlDocReadMe' name='Read Me Help' group='Overview' linkText='Provides static documentaion for the physical memories available in the design.' visible='true' default='' desc='' />

    <ParamString id='cfgFileName' default='`${cy_design_filename() . ".cyqspi"}`'/>
    <ParamString id='cfgFilePath' default='`${cy_design_path() . "/" . cfgFileName}`'/>
    <ParamCustom id='configurator' name='QSPI Configurator' group='Memory Definition Tools' path='`${cy_tools_path("qspi-configurator") . "/qspi-configurator"}`' visible='true' editable='true' desc='Launch QSPI Configurator tool.'>
      <Arg value='`${"--config=" . cfgFilePath}`' />
      <Arg value='`${"--output-dir=" . cy_codegen_path()}`' />
    </ParamCustom>

    <!--Constants defined for use by the tool for error checking.-->
    <!--The maximum number of regions the tool should allow to be created (since it is the most the personality is defined to be able to handle. This is an arbitrarily large number).-->
    <ParamString id='maxSupportedRegions' default='$MAX_REGIONS' />
    <!--The maximum number of available Cores the personality is defined to be able to handle. If an MPN with more needs to be supported this file will need to be updated to accommodate it.-->
    <ParamString id='maxSupportedCores' default='$MAX_CORES' />
    <!--The maximum number of available physical memory view maps the personality is defined to be able to handle. If an MPN with more needs to be supported this file will need to be updated to accommodate it.-->
    <ParamString id='maxSupportedViewMaps' default='$MAX_VIEW_MAPS' />
  </Parameters>

  <Variables>
    <Variable id='numCores' value='`${getVirtualCoreCount()}`'/>
    <Repeat count='$MAX_CORES' repeatId='core'>
      <Variable id='coreId$idx{core}' value='`${$idx{core} &lt; numCores ? splitAt(getVirtualCoreDefineNames(), $idx{core}) : ""}`'/>
      <Variable id='coreShortName$idx{core}' value='`${(coreId$idx{core} ne "") ? getCoreShortDefine(coreId$idx{core}) : ""}`'/>
    </Repeat>

    <Variable id='numRegionsDefined' value='`${memoryRegionCount()}`'/>
    <Repeat count='$MAX_REGIONS' repeatId='reg'>
      <Variable id='regionPhysMemId_$idx{reg}' value='`${$idx{reg} &lt; numRegionsDefined ? getExposedMember(memoryRegionLocation($idx{reg}), "memoryId") : ""}`'/>
      <Variable id='regionOffset_$idx{reg}' value='`${$idx{reg} &lt; numRegionsDefined ? getExposedMember(memoryRegionLocation($idx{reg}), "offset") : ""}`'/>
      <Variable id='regionSize_$idx{reg}' value='`${$idx{reg} &lt; numRegionsDefined ? getExposedMember(memoryRegionLocation($idx{reg}), "size") : ""}`'/>
      <Variable id='regionId_$idx{reg}' value='`${$idx{reg} &lt; numRegionsDefined ? getExposedMember(memoryRegionLocation($idx{reg}), "regionId") : ""}`'/>
      <Variable id='regionDomain_$idx{reg}' value='`${$idx{reg} &lt; numRegionsDefined ? getExposedMember(memoryRegionLocation($idx{reg}), "domain") : ""}`'/>
      <Variable id='regionEndOffset_$idx{reg}' value='`${$idx{reg} &lt; numRegionsDefined ? toHex(regionOffset_$idx{reg} + regionSize_$idx{reg}, 8) : ""}`'/>
      <Repeat count='$MAX_CORES' repeatId='core'>
        <Variable id='regionCoreIsAccessible$idx{core}_$idx{reg}' value='`${getOrDefault(getExposedMember(getBlockFromInstance(regionDomain_$idx{reg}), "coreIsAccessible$idx{core}"), false)}`'/>
        <Variable id='regionViewMapsForCore$idx{core}_$idx{reg}' value='`${$idx{reg} &lt; numRegionsDefined &amp;&amp; regionCoreIsAccessible$idx{core}_$idx{reg} ? memoryViewMaps(regionPhysMemId_$idx{reg}, coreId$idx{core}) : ""}`'/>
        <Variable id='numRegionViewMapsForCore$idx{core}_$idx{reg}' value='`${$idx{reg} &lt; numRegionsDefined &amp;&amp; regionCoreIsAccessible$idx{core}_$idx{reg} ? splitCount(regionViewMapsForCore$idx{core}_$idx{reg}) : ""}`'/>
        <Repeat count='$MAX_VIEW_MAPS' repeatId='view'>
          <Variable id='regionViewMap$idx{view}Id_$idx{core}_$idx{reg}' value='`${$idx{reg} &lt; numRegionsDefined &amp;&amp; regionCoreIsAccessible$idx{core}_$idx{reg} &amp;&amp; $idx{view} &lt; numRegionViewMapsForCore$idx{core}_$idx{reg} ? splitAt(regionViewMapsForCore$idx{core}_$idx{reg}, $idx{view}) : ""}`'/>
          <Variable id='regionViewMapSuffix$idx{view}Id_$idx{core}_$idx{reg}' value='`${$idx{reg} &lt; numRegionsDefined &amp;&amp; regionCoreIsAccessible$idx{core}_$idx{reg} &amp;&amp; $idx{view} &lt; numRegionViewMapsForCore$idx{core}_$idx{reg} ? memoryViewMapSuffix(regionViewMap$idx{view}Id_$idx{core}_$idx{reg}) : ""}`'/>
          <Variable id='regionViewMapIsICache$idx{view}Id_$idx{core}_$idx{reg}' value='`${$idx{reg} &lt; numRegionsDefined &amp;&amp; regionCoreIsAccessible$idx{core}_$idx{reg} &amp;&amp; $idx{view} &lt; numRegionViewMapsForCore$idx{core}_$idx{reg} ? memoryViewMapHasCapability(regionViewMap$idx{view}Id_$idx{core}_$idx{reg}, "ICache") : ""}`'/>
          <Variable id='regionViewMapIsSecure$idx{view}Id_$idx{core}_$idx{reg}' value='`${$idx{reg} &lt; numRegionsDefined &amp;&amp; regionCoreIsAccessible$idx{core}_$idx{reg} &amp;&amp; $idx{view} &lt; numRegionViewMapsForCore$idx{core}_$idx{reg} ? memoryViewMapHasCapability(regionViewMap$idx{view}Id_$idx{core}_$idx{reg}, "Secure") : ""}`'/>
        </Repeat>
      </Repeat>
    </Repeat>

    <!-- Shift Array JSON File Preparation -->
    <Variable id='numMemories' value='`${splitCount(memoryIds())}`'/>
    <Repeat count='$MAX_MEMORIES' repeatId='mem'>
      <Variable id='memoryId$idx{mem}' value='`${$idx{mem} &lt; numMemories ? splitAt(memoryIds(), $idx{mem}) : ""}`'/>
      <Variable id='memorySize$idx{mem}' value='`${($idx{mem} &lt; numMemories) ? toHex(memorySize(memoryId$idx{mem}), 8) : "" }`'/>
      <Repeat count='$MAX_CORES' repeatId='core'>
        <!-- Physical Memory View Maps for each Core -->
        <Variable id='memoryViewMaps$idx{mem}_$idx{core}' value='`${($idx{mem} &lt; numMemories &amp;&amp; $idx{core} &lt; numCores) ? memoryViewMaps(memoryId$idx{mem}, coreId$idx{core}) : ""}`'/>
        <Variable id='numMemoryViewMaps$idx{mem}_$idx{core}' value='`${($idx{mem} &lt; numMemories &amp;&amp; $idx{core} &lt; numCores) ? splitCount(memoryViewMaps$idx{mem}_$idx{core}) : ""}`'/>
        <Repeat count='$MAX_VIEW_MAPS' repeatId='view'>
          <Variable id='memoryViewMap$idx{mem}_$idx{core}_$idx{view}'     value='`${$idx{mem} &lt; numMemories &amp;&amp; $idx{core} &lt; numCores &amp;&amp; $idx{view} &lt; numMemoryViewMaps$idx{mem}_$idx{core} ? splitAt(memoryViewMaps$idx{mem}_$idx{core}, $idx{view}) : ""}`'/>
          <Variable id='memoryViewAddress$idx{mem}_$idx{core}_$idx{view}' value='`${$idx{mem} &lt; numMemories &amp;&amp; $idx{core} &lt; numCores &amp;&amp; $idx{view} &lt; numMemoryViewMaps$idx{mem}_$idx{core} ? toHex(memoryOffsetToAddress(coreId$idx{core}, memoryViewMap$idx{mem}_$idx{core}_$idx{view}, memoryId$idx{mem}, 0), 8) : ""}`'/>
          <Variable id='memoryViewMapIsICache$idx{mem}_$idx{core}_$idx{view}' value='`${$idx{mem} &lt; numMemories &amp;&amp; $idx{core} &lt; numCores &amp;&amp; $idx{view} &lt; numMemoryViewMaps$idx{mem}_$idx{core} ? memoryViewMapHasCapability(memoryViewMap$idx{mem}_$idx{core}_$idx{view}, "ICache") : ""}`'/>
          <Variable id='memoryViewMapIsSecure$idx{mem}_$idx{core}_$idx{view}' value='`${$idx{mem} &lt; numMemories &amp;&amp; $idx{core} &lt; numCores &amp;&amp; $idx{view} &lt; numMemoryViewMaps$idx{mem}_$idx{core} ? memoryViewMapHasCapability(memoryViewMap$idx{mem}_$idx{core}_$idx{view}, "Secure") : ""}`'/>
        </Repeat>
      </Repeat>
    </Repeat>

    <Variable id='tclData' value='`${runTcl("memory-2.0.tcl", createTclArgData())}`'/>
  </Variables>

  <DRCs>
    <!-- Region must be contained in a memory -->
    <DRC condition='`${$idx &lt; numRegionsDefined &amp;&amp; !hasMemory(regionPhysMemId_$idx)}`' type='ERROR'
         text='Memory region "`${regionId_$idx}`" is allocated to the non-existent physical memory "`${memoryDisplayName(regionPhysMemId_$idx)}`".'
         repeatCount='$MAX_REGIONS' paramId='$idx' >
      <FixIt action='DISABLE_BLOCK' target='`${memoryRegionLocation($idx)}`' valid='true' description='Unallocate memory region "`${regionId_$idx}`"' />
    </DRC>
    <!-- regionOffset_$idx must be within memorySize -->
    <DRC condition='`${$idx &lt; numRegionsDefined &amp;&amp; hasMemory(regionPhysMemId_$idx) &amp;&amp; regionOffset_$idx &gt;= memorySize(regionPhysMemId_$idx)}`' type='ERROR'
         text='Memory region "`${regionId_$idx}`" must begin within physical memory "`${memoryDisplayName(regionPhysMemId_$idx)}`".'
         repeatCount='$MAX_REGIONS' paramId='$idx' />
    <!-- regionOffset_$idx is unsigned so it cannot be less than 0 -->
    <DRC condition='`${$idx &lt; numRegionsDefined &amp;&amp; hasMemory(regionPhysMemId_$idx) &amp;&amp; regionOffset_$idx &lt; memorySize(regionPhysMemId_$idx) &amp;&amp; regionEndOffset_$idx &gt; memorySize(regionPhysMemId_$idx)}`' type='ERROR'
         text='Memory region "`${regionId_$idx}`" does not fit within physical memory "`${memoryDisplayName(regionPhysMemId_$idx)}`".'
         repeatCount='$MAX_REGIONS' paramId='$idx' >
      <FixIt action='SET_PARAM' target='`${memoryRegionLocation($idx)}`.size' value='`${toHex(memorySize(regionPhysMemId_$idx) - regionOffset_$idx)}`' valid='`${(memorySize(regionPhysMemId_$idx) - regionOffset_$idx) &gt; 0}`' description='Change size of memory region "`${regionId_$idx}`" to `${toHex(memorySize(regionPhysMemId_$idx) - regionOffset_$idx)}`' />
    </DRC>
    <!-- Regions must not overlap -->
    <DRC condition='`${($idx+1) &lt; numRegionsDefined &amp;&amp; regionPhysMemId_$idx eq lookupExpression("regionPhysMemId_" . ($idx+1)) &amp;&amp; regionEndOffset_$idx &gt; lookupExpression("regionOffset_" . ($idx+1)) }`'
         type='ERROR' repeatCount='255'
         text='Memory region "`${regionId_$idx}`" overlaps with memory region "`${lookupExpression("regionId_" . ($idx+1))}`". Note: The &apos;Autocorrect overlaps&apos; feature on the Memory tab can be used to fix this issue.' paramId='$idx' >
      <!-- Set size of overlapping region to as large as it can be without overlapping the next region and while still being aligned with the physical memory constraints -->
      <FixIt action='SET_PARAM' target='`${memoryRegionLocation($idx)}`.size' value='`${toHex(floor((lookupExpression("regionOffset_" . ($idx+1)) - regionOffset_$idx)/memoryAlignment(regionPhysMemId_$idx))*memoryAlignment(regionPhysMemId_$idx))}`' valid='`${floor((lookupExpression("regionOffset_" . ($idx+1)) - regionOffset_$idx)/memoryAlignment(regionPhysMemId_$idx))*memoryAlignment(regionPhysMemId_$idx) &gt; 0}`' description='Change size of memory region "`${regionId_$idx}`" to `${toHex(floor((lookupExpression("regionOffset_" . ($idx+1)) - regionOffset_$idx)/memoryAlignment(regionPhysMemId_$idx))*memoryAlignment(regionPhysMemId_$idx))}`' />
    </DRC>
    <!-- Regions that have different domains should not share a memory block -->
    <DRC condition='`${($idx+1) &lt; numRegionsDefined &amp;&amp; regionPhysMemId_$idx eq lookupExpression("regionPhysMemId_" . ($idx+1)) &amp;&amp; regionEndOffset_$idx &lt;= lookupExpression("regionOffset_" . ($idx+1)) &amp;&amp; (regionEndOffset_$idx-1)/memoryAlignment(regionPhysMemId_$idx) == lookupExpression("regionOffset_" . ($idx+1))/memoryAlignment(regionPhysMemId_$idx) &amp;&amp; regionDomain_$idx ne lookupExpression("regionDomain_" . ($idx+1)) }`'
         type='INFO' repeatCount='255'
         text='Memory regions "`${regionId_$idx}`" and "`${lookupExpression("regionId_" . ($idx+1))}`" share the same erase block (size `${toHex(memoryAlignment(regionPhysMemId_$idx))}`) but are assigned to different domains. Reprogramming one domain will erase the data used by the other domain.' paramId='$idx' />
  </DRCs>

  <ConfigFirmware>
    <!-- cymem_memory_types.h -->
    <ConfigFile repeatCount='1' name='cymem_memory_types.h'>
      <Line value='/* This file is automatically generated. */'/>
      <Line value='#if !defined(CYMEM_MEMORY_TYPES_H)' />
      <Line value='#define CYMEM_MEMORY_TYPES_H'/>
      <Line value=''/>
      <Repeat count='`${numMemories}`' repeatId='mem'>
        <Line value='#define $MEMORY_LOCATION_PREFIX`${memoryId$idx{mem}}` ($idx{mem})' />
      </Repeat>
      <Line value=''/>
      <Line value='#define IS_SMIF_MEMORY(mem) ( \'/>
      <Repeat count='`${numMemories}`' repeatId='mem'>
        <Line value='    (mem == $MEMORY_LOCATION_PREFIX`${memoryId$idx{mem}}`) ? 1 : \' include='`${hasMatch(memoryId$idx{mem}, "^SMIF")}`' />
      </Repeat>
      <Line value='    0 \'/>
      <Line value=')'/>
      <Line value=''/>
      <Line value='#endif /* CYMEM_MEMORY_TYPES_H */'/>
    </ConfigFile>

    <!-- cymem_memory_locations.h -->
    <ConfigFile repeatCount='1' name='cymem_memory_locations.h'>
      <Line value='/* This file is automatically generated. */'/>
      <Line value='#if !defined(CYMEM_MEMORY_LOCATIONS_H)' />
      <Line value='#define CYMEM_MEMORY_LOCATIONS_H'/>
      <Line value=''/>
      <Line value='#include "cymem_memory_types.h"'/>
      <Line value=''/>
      <Repeat count='`${numCores}`' repeatId='core'>
        <Repeat count='`${numMemories}`' repeatId='mem'>
          <Repeat count='`${numRegionsDefined}`' repeatId='reg'>
            <Line include='`${regionPhysMemId_$idx{reg} eq memoryId$idx{mem} &amp;&amp; regionCoreIsAccessible$idx{core}_$idx{reg}}`' value='#define CYMEM_`${getTclVar("regionBaseName$idx{core}_$idx{reg}", tclData)}`_LOCATION $MEMORY_LOCATION_PREFIX`${regionPhysMemId_$idx{reg}}`' />
          </Repeat>
        </Repeat>
      </Repeat>

      <Line value=''/>
      <Line value='#endif /* CYMEM_MEMORY_LOCATIONS_H */'/>
    </ConfigFile>

    <!-- GNU ld -->
    <ConfigFile repeatCount='`${numCores}`' name='cymem_gnu_`${coreShortName$idx{core}}`.ld' repeatId='core'>
      <Line value='/* This file is automatically generated. */'/>
      <Line value=''/>
      <Repeat count='`${numMemories}`' repeatId='mem'>
        <Repeat count='`${numRegionsDefined}`' repeatId='reg'>
          <Repeat count='`${(regionPhysMemId_$idx{reg} eq memoryId$idx{mem} &amp;&amp; regionCoreIsAccessible$idx{core}_$idx{reg}) ? numRegionViewMapsForCore$idx{core}_$idx{reg} : 0}`' repeatId='view'>
            <Line value='CYMEM_`${getTclVar("regionBaseName$idx{core}_$idx{reg}", tclData)}``${memoryViewMapSuffix(regionViewMap$idx{view}Id_$idx{core}_$idx{reg})}`_START = `${toHex(memoryOffsetToAddress(coreId$idx{core}, regionViewMap$idx{view}Id_$idx{core}_$idx{reg}, regionPhysMemId_$idx{reg}, regionOffset_$idx{reg}), 8)}`;' />
          </Repeat>
          <Line
            include='`${regionPhysMemId_$idx{reg} eq memoryId$idx{mem} &amp;&amp; regionCoreIsAccessible$idx{core}_$idx{reg}}`'
            value='CYMEM_`${getTclVar("regionBaseName$idx{core}_$idx{reg}", tclData)}`_SIZE = `${toHex(regionSize_$idx{reg}, 8)}`;' />
          <Line
            include='`${regionPhysMemId_$idx{reg} eq memoryId$idx{mem} &amp;&amp; regionCoreIsAccessible$idx{core}_$idx{reg}}`'
            value='CYMEM_`${getTclVar("regionBaseName$idx{core}_$idx{reg}", tclData)}`_OFFSET = `${toHex(regionOffset_$idx{reg}, 8)}`;' />
        </Repeat>
      </Repeat>
      <Line value=''/>
      <Line value='MEMORY'/>
      <Line value='{'/>
      <Repeat count='`${numMemories}`' repeatId='mem'>
        <Repeat count='`${numRegionsDefined}`' repeatId='reg'>
          <Repeat count='`${(regionPhysMemId_$idx{reg} eq memoryId$idx{mem} &amp;&amp; regionCoreIsAccessible$idx{core}_$idx{reg}) ? numRegionViewMapsForCore$idx{core}_$idx{reg} : 0}`' repeatId='view'>
            <Line value='    `${regionId_$idx{reg}}``${memoryViewMapSuffix(regionViewMap$idx{view}Id_$idx{core}_$idx{reg})}` : ORIGIN = `${toHex(memoryOffsetToAddress(coreId$idx{core}, regionViewMap$idx{view}Id_$idx{core}_$idx{reg}, regionPhysMemId_$idx{reg}, regionOffset_$idx{reg}), 8)}`, LENGTH = `${toHex(regionSize_$idx{reg}, 8)}`' />
          </Repeat>
        </Repeat>
      </Repeat>
      <Line value='}'/>
      <Line value=''/>
      <Repeat count='`${numMemories}`' repeatId='mem'>
        <Repeat count='`${numRegionsDefined}`' repeatId='reg'>
          <Line
            include='`${(getOrDefault(getTclVar("regionHasEmptyCapability$idx{core}_$idx{reg}", tclData), -1) != -1 || getOrDefault(getTclVar("regionHasCacheCapability$idx{core}_$idx{reg}", tclData), -1) != -1) &amp;&amp; regionPhysMemId_$idx{reg} eq memoryId$idx{mem} &amp;&amp; regionCoreIsAccessible$idx{core}_$idx{reg}}`'
            value='REGION_ALIAS("`${regionId_$idx{reg}}`_sel", `${regionId_$idx{reg}}``${getTclVar("regionSelectedSuffix$idx{core}_$idx{reg}", tclData)}`)' />
          <Line
            include='`${(getOrDefault(getTclVar("regionHasSecureCapability$idx{core}_$idx{reg}", tclData), -1) != -1 || getOrDefault(getTclVar("regionHasCacheSecureCapability$idx{core}_$idx{reg}", tclData), -1) != -1 ) &amp;&amp; regionPhysMemId_$idx{reg} eq memoryId$idx{mem} &amp;&amp; regionCoreIsAccessible$idx{core}_$idx{reg}}`'
            value='REGION_ALIAS("`${regionId_$idx{reg}}`_sel_S", `${regionId_$idx{reg}}``${getTclVar("regionSelectedSecureSuffix$idx{core}_$idx{reg}", tclData)}`)' />
        </Repeat>
      </Repeat>
    </ConfigFile>

    <!-- armlink -->
    <ConfigFile repeatCount='`${numCores}`' name='cymem_armlink_`${coreShortName$idx{core}}`.sct' repeatId='core'>
      <Line value='; This file is automatically generated.'/>
      <Repeat count='`${numMemories}`' repeatId='mem'>
        <Repeat count='`${numRegionsDefined}`' repeatId='reg'>
          <Repeat count='`${regionPhysMemId_$idx{reg} eq memoryId$idx{mem} &amp;&amp;regionCoreIsAccessible$idx{core}_$idx{reg} ? numRegionViewMapsForCore$idx{core}_$idx{reg} : 0}`' repeatId='view'>
            <Line value='#define CYMEM_`${getTclVar("regionBaseName$idx{core}_$idx{reg}", tclData)}``${memoryViewMapSuffix(regionViewMap$idx{view}Id_$idx{core}_$idx{reg})}`_START `${toHex(memoryOffsetToAddress(coreId$idx{core}, regionViewMap$idx{view}Id_$idx{core}_$idx{reg}, regionPhysMemId_$idx{reg}, regionOffset_$idx{reg}), 8)}`' />
          </Repeat>
          <Line
            include='`${regionPhysMemId_$idx{reg} eq memoryId$idx{mem} &amp;&amp; regionCoreIsAccessible$idx{core}_$idx{reg}}`'
            value='#define CYMEM_`${getTclVar("regionBaseName$idx{core}_$idx{reg}", tclData)}`_SIZE `${toHex(regionSize_$idx{reg}, 8)}`' />
          <Line
            include='`${regionPhysMemId_$idx{reg} eq memoryId$idx{mem} &amp;&amp; regionCoreIsAccessible$idx{core}_$idx{reg}}`'
            value='#define CYMEM_`${getTclVar("regionBaseName$idx{core}_$idx{reg}", tclData)}`_OFFSET `${toHex(regionOffset_$idx{reg}, 8)}`' />
          <Line
            include='`${(getOrDefault(getTclVar("regionHasEmptyCapability$idx{core}_$idx{reg}", tclData), -1) != -1 || getOrDefault(getTclVar("regionHasCacheCapability$idx{core}_$idx{reg}", tclData), -1) != -1) &amp;&amp; regionPhysMemId_$idx{reg} eq memoryId$idx{mem} &amp;&amp; regionCoreIsAccessible$idx{core}_$idx{reg}}`'
            value='#define CYMEM_`${getTclVar("regionBaseName$idx{core}_$idx{reg}", tclData)}`_sel_START CYMEM_`${getTclVar("regionSelectedFullName$idx{core}_$idx{reg}", tclData)}`_START' />
          <Line
            include='`${(getOrDefault(getTclVar("regionHasSecureCapability$idx{core}_$idx{reg}", tclData), -1) != -1 || getOrDefault(getTclVar("regionHasCacheSecureCapability$idx{core}_$idx{reg}", tclData), -1) != -1 ) &amp;&amp; regionPhysMemId_$idx{reg} eq memoryId$idx{mem} &amp;&amp; regionCoreIsAccessible$idx{core}_$idx{reg}}`'
            value='#define CYMEM_`${getTclVar("regionBaseName$idx{core}_$idx{reg}", tclData)}`_sel_S_START CYMEM_`${getTclVar("regionSelectedSecureFullName$idx{core}_$idx{reg}", tclData)}`_START' />
        </Repeat>
      </Repeat>
    </ConfigFile>

    <!-- ilinkarm -->
    <ConfigFile repeatCount='`${numCores}`' name='cymem_ilinkarm_`${coreShortName$idx{core}}`.icf' repeatId='core'>
      <Line value='// This file is automatically generated.'/>
      <Repeat count='`${numMemories}`' repeatId='mem'>
        <Repeat count='`${numRegionsDefined}`' repeatId='reg'>
          <Repeat count='`${regionPhysMemId_$idx{reg} eq memoryId$idx{mem} &amp;&amp;regionCoreIsAccessible$idx{core}_$idx{reg} ? numRegionViewMapsForCore$idx{core}_$idx{reg} : 0}`' repeatId='view'>
            <Line value='define exported symbol CYMEM_`${getTclVar("regionBaseName$idx{core}_$idx{reg}", tclData)}``${memoryViewMapSuffix(regionViewMap$idx{view}Id_$idx{core}_$idx{reg})}`_START = `${toHex(memoryOffsetToAddress(coreId$idx{core}, regionViewMap$idx{view}Id_$idx{core}_$idx{reg}, regionPhysMemId_$idx{reg}, regionOffset_$idx{reg}), 8)}`;' />
          </Repeat>
          <Line
            include='`${regionPhysMemId_$idx{reg} eq memoryId$idx{mem} &amp;&amp; regionCoreIsAccessible$idx{core}_$idx{reg}}`'
            value='define exported symbol CYMEM_`${getTclVar("regionBaseName$idx{core}_$idx{reg}", tclData)}`_SIZE = `${toHex(regionSize_$idx{reg}, 8)}`;' />
          <Line
            include='`${regionPhysMemId_$idx{reg} eq memoryId$idx{mem} &amp;&amp; regionCoreIsAccessible$idx{core}_$idx{reg}}`'
            value='define exported symbol CYMEM_`${getTclVar("regionBaseName$idx{core}_$idx{reg}", tclData)}`_OFFSET = `${toHex(regionOffset_$idx{reg}, 8)}`;' />
          <Line
            include='`${(getOrDefault(getTclVar("regionHasEmptyCapability$idx{core}_$idx{reg}", tclData), -1) != -1 || getOrDefault(getTclVar("regionHasCacheCapability$idx{core}_$idx{reg}", tclData), -1) != -1) &amp;&amp; regionPhysMemId_$idx{reg} eq memoryId$idx{mem} &amp;&amp; regionCoreIsAccessible$idx{core}_$idx{reg}}`'
            value='define exported symbol CYMEM_`${getTclVar("regionBaseName$idx{core}_$idx{reg}", tclData)}`_sel_START = CYMEM_`${getTclVar("regionSelectedFullName$idx{core}_$idx{reg}", tclData)}`_START;' />
          <Line
            include='`${(getOrDefault(getTclVar("regionHasSecureCapability$idx{core}_$idx{reg}", tclData), -1) != -1 || getOrDefault(getTclVar("regionHasCacheSecureCapability$idx{core}_$idx{reg}", tclData), -1) != -1 ) &amp;&amp; regionPhysMemId_$idx{reg} eq memoryId$idx{mem} &amp;&amp; regionCoreIsAccessible$idx{core}_$idx{reg}}`'
            value='define exported symbol CYMEM_`${getTclVar("regionBaseName$idx{core}_$idx{reg}", tclData)}`_sel_S_START = CYMEM_`${getTclVar("regionSelectedSecureFullName$idx{core}_$idx{reg}", tclData)}`_START;' />
        </Repeat>
      </Repeat>
    </ConfigFile>

    <ConfigFile repeatCount='`${numCores}`' name='cymem_ilinkarm_regions_`${coreShortName$idx{core}}`.icf' repeatId='core'>
      <Line value='// This file is automatically generated.'/>
      <Line value='// define memory with size = 4G;'/>
      <Repeat count='`${numMemories}`' repeatId='mem'>
        <Repeat count='`${numRegionsDefined}`' repeatId='reg'>
          <Repeat count='`${regionPhysMemId_$idx{reg} eq memoryId$idx{mem} &amp;&amp;regionCoreIsAccessible$idx{core}_$idx{reg} ? numRegionViewMapsForCore$idx{core}_$idx{reg} : 0}`' repeatId='view'>
            <Line value='define region `${regionId_$idx{reg}}``${memoryViewMapSuffix(regionViewMap$idx{view}Id_$idx{core}_$idx{reg})}` = [from CYMEM_`${getTclVar("regionBaseName$idx{core}_$idx{reg}", tclData)}``${memoryViewMapSuffix(regionViewMap$idx{view}Id_$idx{core}_$idx{reg})}`_START size CYMEM_`${getTclVar("regionBaseName$idx{core}_$idx{reg}", tclData)}`_SIZE];' />
          </Repeat>
          <Line
            include='`${(getOrDefault(getTclVar("regionHasEmptyCapability$idx{core}_$idx{reg}", tclData), -1) != -1 || getOrDefault(getTclVar("regionHasCacheCapability$idx{core}_$idx{reg}", tclData), -1) != -1) &amp;&amp; regionPhysMemId_$idx{reg} eq memoryId$idx{mem} &amp;&amp; regionCoreIsAccessible$idx{core}_$idx{reg}}`'
            value='define region `${regionId_$idx{reg}}`_sel = [from CYMEM_`${getTclVar("regionSelectedFullName$idx{core}_$idx{reg}", tclData)}`_START size CYMEM_`${getTclVar("regionBaseName$idx{core}_$idx{reg}", tclData)}`_SIZE];' />
          <Line
            include='`${(getOrDefault(getTclVar("regionHasSecureCapability$idx{core}_$idx{reg}", tclData), -1) != -1 || getOrDefault(getTclVar("regionHasCacheSecureCapability$idx{core}_$idx{reg}", tclData), -1) != -1 ) &amp;&amp; regionPhysMemId_$idx{reg} eq memoryId$idx{mem} &amp;&amp; regionCoreIsAccessible$idx{core}_$idx{reg}}`'
            value='define region `${regionId_$idx{reg}}`_sel_S = [from CYMEM_`${getTclVar("regionSelectedSecureFullName$idx{core}_$idx{reg}", tclData)}`_START size CYMEM_`${getTclVar("regionBaseName$idx{core}_$idx{reg}", tclData)}`_SIZE];' />
        </Repeat>
      </Repeat>
    </ConfigFile>

    <!-- C header file -->
    <ConfigFile repeatCount='`${numCores}`' name='cymem_`${coreShortName$idx{core}}`.h' repeatId='core'>
      <Line value='/* This file is automatically generated. */'/>
      <Line value='#if !defined(CYMEM_`${coreShortName$idx{core}}`_H)' />
      <Line value='#define CYMEM_`${coreShortName$idx{core}}`_H'/>
      <Line value=''/>
      <Repeat count='`${numMemories}`' repeatId='mem'>
        <Repeat count='`${numRegionsDefined}`' repeatId='reg'>
          <Repeat count='`${regionPhysMemId_$idx{reg} eq memoryId$idx{mem} &amp;&amp;regionCoreIsAccessible$idx{core}_$idx{reg} ? numRegionViewMapsForCore$idx{core}_$idx{reg} : 0}`' repeatId='view'>
            <Line value='#define CYMEM_`${getTclVar("regionBaseName$idx{core}_$idx{reg}", tclData)}``${memoryViewMapSuffix(regionViewMap$idx{view}Id_$idx{core}_$idx{reg})}`_START `${toHex(memoryOffsetToAddress(coreId$idx{core}, regionViewMap$idx{view}Id_$idx{core}_$idx{reg}, regionPhysMemId_$idx{reg}, regionOffset_$idx{reg}), 8)}`u' />
          </Repeat>
          <Line
            include='`${regionPhysMemId_$idx{reg} eq memoryId$idx{mem} &amp;&amp; regionCoreIsAccessible$idx{core}_$idx{reg}}`'
            value='#define CYMEM_`${getTclVar("regionBaseName$idx{core}_$idx{reg}", tclData)}`_SIZE `${toHex(regionSize_$idx{reg}, 8)}`u' />
          <Line
            include='`${regionPhysMemId_$idx{reg} eq memoryId$idx{mem} &amp;&amp; regionCoreIsAccessible$idx{core}_$idx{reg}}`'
            value='#define CYMEM_`${getTclVar("regionBaseName$idx{core}_$idx{reg}", tclData)}`_OFFSET `${toHex(regionOffset_$idx{reg}, 8)}`u' />
        </Repeat>
      </Repeat>
      <Line value='' />
      <Line value='#endif /* CYMEM_`${coreShortName$idx{core}}`_H */'/>
    </ConfigFile>

    <!-- Shift Array JSON file -->
    <ConfigFile name='edgeproctectsymbols.json'>
      <Line value='{' />
      <Line value='    "symbolInformation" :' />
      <Line value='    [' />
      <Repeat count='`${numCores}`' repeatId='core'>
        <Repeat count='`${numMemories}`' repeatId='mem'>
          <Repeat count='`${numRegionsDefined}`' repeatId='reg'>
            <Repeat count='`${(regionPhysMemId_$idx{reg} eq memoryId$idx{mem} &amp;&amp; regionCoreIsAccessible$idx{core}_$idx{reg}) ? numRegionViewMapsForCore$idx{core}_$idx{reg} : 0}`' repeatId='view'>
              <Line value='        { "name" : "CYMEM_`${getTclVar("regionBaseName$idx{core}_$idx{reg}", tclData)}``${memoryViewMapSuffix(regionViewMap$idx{view}Id_$idx{core}_$idx{reg})}`_START", "value" :  "`${toHex(memoryOffsetToAddress(coreId$idx{core}, regionViewMap$idx{view}Id_$idx{core}_$idx{reg}, regionPhysMemId_$idx{reg}, regionOffset_$idx{reg}), 8)}`" },'/>
            </Repeat>
            <Line
              include='`${regionPhysMemId_$idx{reg} eq memoryId$idx{mem} &amp;&amp; regionCoreIsAccessible$idx{core}_$idx{reg}}`'
              value='        { "name" : "CYMEM_`${getTclVar("regionBaseName$idx{core}_$idx{reg}", tclData)}`_SIZE", "value" : "`${toHex(regionSize_$idx{reg}, 8)}`" },'/>
            <Line
              include='`${regionPhysMemId_$idx{reg} eq memoryId$idx{mem} &amp;&amp; regionCoreIsAccessible$idx{core}_$idx{reg}}`'
              value='        { "name" : "CYMEM_`${getTclVar("regionBaseName$idx{core}_$idx{reg}", tclData)}`_OFFSET", "value" : "`${toHex(regionOffset_$idx{reg}, 8)}`" },'/>
          </Repeat>
        </Repeat>
      </Repeat>
      <Line value='        {' />
      <Line value='            "name" : "RelocationTable",' />
      <Line value='            "value" :' />
      <Line value='            [' />
      <!-- We want an entry for every shift array entry, but no trailing comma -->
      <Line value='                { `${($idx == (getTclVar("numShiftArrayEntries", tclData) - 1)) ? splitAt(getTclVar("shiftArrayEntriesTotal", tclData), $idx) . " }": splitAt(getTclVar("shiftArrayEntriesTotal", tclData), $idx) . " },"}`' repeatCount='`${getTclVar("numShiftArrayEntries", tclData)}`'/>
      <Line value='            ]' />
      <Line value='        }' />
      <Line value='    ],' />
      <Line value='    "version" : 1' />
      <Line value='}' />
    </ConfigFile>
  </ConfigFirmware>
</PersonalityTemplate>
